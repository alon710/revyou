rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // ====== HELPER FUNCTIONS ======

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user owns the document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Validate string length
    function validStringLength(str, min, max) {
      return str is string && str.size() >= min && str.size() <= max;
    }

    // Validate subscription tier
    function isValidTier(tier) {
      return tier in ['free', 'basic', 'pro', 'enterprise'];
    }

    // Validate tone of voice
    function isValidTone(tone) {
      return tone in ['friendly', 'formal', 'humorous', 'professional'];
    }

    // Validate language mode
    function isValidLanguageMode(mode) {
      return mode in ['hebrew', 'english', 'auto-detect'];
    }

    // Validate reply status
    function isValidReplyStatus(status) {
      return status in ['pending', 'rejected', 'posted', 'failed'];
    }

    // Validate rating (1-5)
    function isValidRating(rating) {
      return rating is int && rating >= 1 && rating <= 5;
    }

    // ====== USERS COLLECTION ======
    match /users/{userId} {
      // Users can read and write their own data
      allow read: if isOwner(userId);

      allow create: if isOwner(userId) &&
      request.resource.data.keys().hasAll(['uid', 'email', 'displayName', 'photoURL', 'createdAt', 'subscriptionTier']) &&
      request.resource.data.uid == userId &&
      request.resource.data.email is string &&
      validStringLength(request.resource.data.displayName, 1, 200) &&
      request.resource.data.photoURL is string &&
      isValidTier(request.resource.data.subscriptionTier);

      allow update: if isOwner(userId) &&
      // Cannot change uid or createdAt
      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['uid', 'createdAt'])) &&
      // Validate subscription tier if changed
      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['subscriptionTier']) ||
      isValidTier(request.resource.data.subscriptionTier));

      allow delete: if false; // Users should not be deleted via Firestore

      // ====== STRIPE SUBSCRIPTIONS (Firestore Stripe Extension) ======
      // Subscriptions subcollection managed by Stripe extension
      match /subscriptions/{subscriptionId} {
        // Users can read their own subscriptions
        allow read: if isOwner(userId);

        // Only the Stripe extension and admin can write
        allow write: if false;
      }

      // Checkout sessions subcollection managed by Stripe extension
      match /checkout_sessions/{sessionId} {
        // Users can read and create their own checkout sessions
        allow read, write: if isOwner(userId);
      }

      // Payments subcollection managed by Stripe extension
      match /payments/{paymentId} {
        // Users can read their own payments
        allow read: if isOwner(userId);

        // Only the Stripe extension and admin can write
        allow write: if false;
      }

      // ====== LOCATIONS SUBCOLLECTION ======
      match /locations/{locationId} {
        // Users can read their own locations (ownership implicit via path)
        allow read: if isOwner(userId);

        // Users can create locations in their own subcollection
        allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['googleAccountId', 'googleLocationId', 'name', 'address', 'connected', 'connectedAt', 'config', 'emailOnNewReview']) &&
        validStringLength(request.resource.data.name, 1, 200) &&
        validStringLength(request.resource.data.address, 1, 500) &&
        request.resource.data.connected is bool &&
        request.resource.data.emailOnNewReview is bool &&
        (!('phoneNumber' in request.resource.data) || validStringLength(request.resource.data.phoneNumber, 0, 50)) &&
        (!('websiteUrl' in request.resource.data) || request.resource.data.websiteUrl is string) &&
        (!('mapsUrl' in request.resource.data) || request.resource.data.mapsUrl is string) &&
        (!('description' in request.resource.data) || validStringLength(request.resource.data.description, 0, 5000)) &&
        // Validate config structure
        request.resource.data.config.keys().hasAll(['name', 'toneOfVoice', 'useEmojis', 'languageMode', 'starConfigs']) &&
        validStringLength(request.resource.data.config.name, 1, 200) &&
        (!('description' in request.resource.data.config) || validStringLength(request.resource.data.config.description, 0, 2000)) &&
        (!('phoneNumber' in request.resource.data.config) || validStringLength(request.resource.data.config.phoneNumber, 0, 50)) &&
        isValidTone(request.resource.data.config.toneOfVoice) &&
        isValidLanguageMode(request.resource.data.config.languageMode) &&
        request.resource.data.config.useEmojis is bool;

        // Users can update their own locations
        allow update: if isOwner(userId);

        // Users can delete their own locations
        allow delete: if isOwner(userId);

        // ====== REVIEWS SUBCOLLECTION ======
        match /reviews/{reviewId} {
          // Users can read reviews in their own locations (ownership implicit via path)
          allow read: if isOwner(userId);

          // Cloud Functions and users can create reviews
          allow create: if isOwner(userId) &&
          request.resource.data.keys().hasAll(['googleReviewId', 'name', 'rating', 'date', 'receivedAt', 'replyStatus']) &&
          validStringLength(request.resource.data.name, 1, 200) &&
          isValidRating(request.resource.data.rating) &&
          (!('text' in request.resource.data) || validStringLength(request.resource.data.text, 0, 5000)) &&
          isValidReplyStatus(request.resource.data.replyStatus);

          // Users and Cloud Functions can update reviews
          allow update: if isOwner(userId) &&
          // Validate reply status if changed
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['replyStatus']) ||
          isValidReplyStatus(request.resource.data.replyStatus)) &&
          // Validate aiReply length if provided
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['aiReply']) ||
          (request.resource.data.aiReply == null || validStringLength(request.resource.data.aiReply, 0, 2000)));

          // Reviews should not be deleted directly (keep for history)
          allow delete: if false;
        }
      }
    }

    // ====== PRODUCTS COLLECTION (Stripe Extension) ======
    match /products/{productId} {
      // Anyone can read products (for pricing page)
      allow read: if true;

      // Only admin can write (synced from Stripe)
      allow write: if false;

      // Prices subcollection
      match /prices/{priceId} {
        // Anyone can read prices
        allow read: if true;

        // Only admin can write
        allow write: if false;
      }
    }
  }
}
